MIT/GNU Scheme running under GNU/Linux
Type `^C' (control-C) followed by `H' to obtain information about interrupts.

Copyright (C) 2011 Massachusetts Institute of Technology
This is free software; see the source for copying conditions. There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Image saved on Tuesday October 22, 2013 at 12:31:09 PM
  Release 9.1.1 || Microcode 15.3 || Runtime 15.7 || SF 4.41 || LIAR/i386 4.118
  Edwin 3.116

1 ]=> (define (sum-int a b)
  (if (> a b)
    0
    (+ a (sum-int (+ 1 a) b))))
;Value: sum-int

1 ]=> (sum-int 1 100)
;Value: 5050

1 ]=> (define (from-to term a next b)
  (if (> a b)
    0
    (+ (term a) (from-to term (next a) next b))))
;Value: from-to

1 ]=> ;1.30
(define (from-to-iter term a next b)
  (define (iter a result)
    (if (> a b)
      result
      (iter (next a) (+ result (term a)))))
  (iter a 0))
;Value: from-to-iter

1 ]=> (define (inc a)
  (+ 1 a))
;Value: inc

1 ]=> (define (cube a)
  (* a a a))
;Value: cube

1 ]=> (define (sum-cube a b)
  (from-to cube a inc b))
;Value: sum-cube

1 ]=> (define (sum-cube-iter a b)
  (from-to-iter cube a inc b))
;Value: sum-cube-iter

1 ]=> (define (sum-integer a b)
  (from-to + a inc b))
;Value: sum-integer

1 ]=> (define (pi-sum a b)
  (define (add-4 a)
    (+ a 4))
  (define (pi-sub a)
    (/ 1.0 (* a (+ a 2))))
  (from-to pi-sub a add-4 b))
;Value: pi-sum

1 ]=> (sum-cube 1 100)
;Value: 25502500

1 ]=> (sum-integer 1 100)
;Value: 5050

1 ]=> (pi-sum 1 100)
;Value: .3901993315738763

1 ]=> (define (integral f a b dx)
  (define (add-dx a)
    (+ a dx))
  (* (from-to f (+ a (/ dx 2.0)) add-dx b) dx))
;Value: integral

1 ]=> (define (integral-cube a b)
  (integral cube a b 0.01))
;Value: integral-cube

1 ]=> (integral-cube 0 1)
;Value: .24998750000000042

1 ]=> (sum-cube 5 100)
;Value: 25502400

1 ]=> (sum-cube-iter 5 100)
;Value: 25502400

1 ]=> ;1.31
(define (product func a next b)
  (if (> a b)
    1
    (* (func a) (product func (next a) next b))))
;Value: product

1 ]=> (define (new-fact n)
  (product + 1 inc n))
;Value: new-fact

1 ]=> (new-fact 5)
;Value: 120

1 ]=> (define (product-pi n)
  (define (square n)
    (* n n))
  (define (next-n n)
    (+ n 2))
  (define (func n)
    (square (/ (+ n 1) n)))
  (/ (* 2 (product func 3.0 next-n n)) n))
;Value: product-pi

1 ]=> (* 4 (product-pi 15))
;Value: 3.457335328862911

1 ]=> ;1.32
(define (accumulate combiner null-val func a next b)
  (if (> a b)
    null-val
    (combiner (func a) (accumulate combiner null-val func (next a) next b))))
;Value: accumulate

1 ]=> (define (accumulate-iter combiner null-val func a next b)
  (define (inner combiner func a next b place)
    (if (> a b)
      place
      (inner combiner func (next a) next b (combiner a place))))
  (inner combiner func a next b null-val))
;Value: accumulate-iter

1 ]=> (define (product-new func a next b)
  (accumulate * 1 func a next b))
;Value: product-new

1 ]=> (define (new-new-fact n)
  (product-new + 1 inc n))
;Value: new-new-fact

1 ]=> (new-new-fact 5)
;Value: 120

1 ]=> (define (product-new-iter func a next b)
  (accumulate * 1 func a next b))
;Value: product-new-iter

1 ]=> (define (new-new-fact-iter n)
  (product-new-iter + 1 inc n))
;Value: new-new-fact-iter

1 ]=> (new-new-fact 5)
;Value: 120

1 ]=> ;1.33
(define (accumulate2 predicate combiner null-val func a next b)
  (cond 
    ((> a b) null-val)
    ((predicate a)(combiner (func a) (accumulate2 predicate combiner null-val func (next a) next b)))
    (else (accumulate2 predicate combiner null-val func (next a) next b))))
;Value: accumulate2

1 ]=> (define (product2 func a next b)
  (accumulate2 > * 1 func a next b))
;Value: product2

1 ]=> (define (fact2 n)
  (product2 + 1 inc n))
;Value: fact2

1 ]=> (fact2 5)
;Value: 120

1 ]=> (define (accumulate-prime a b)
  (accumulate2 even? + 0 square a (lambda (x) (+ x 1)) b))
;Value: accumulate-prime

1 ]=> (accumulate-prime 1 100)
;Value: 171700

1 ]=> ;1.3.2
(define (pi-sum a b)
  (from-to 
    (lambda (x) (/ 1.0 (* x (+ x 2)))) 
    a 
    (lambda (x) (+ x 4))
    b))
;Value: pi-sum

1 ]=> (pi-sum 1 40)
;Value: .3864529758334798

1 ]=> ((lambda (x y z) (+ x y z)) 1 2 3)
;Value: 6

1 ]=> (define (func-f x y)
  (let ((a (+ 1 (* x y)))
	(b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))
;Value: func-f

1 ]=> (func-f 5 5)
;Value: 3256

1 ]=> (+ (let ((x 3))
     (+ x (* x 10))) 5)
;Value: 38

1 ]=> ;1.34
;(define (f g)
;  (g 2))
;error
;
;1.3.3

(define (average a b)
  (/ (+ a b) 2.0))
;Value: average

1 ]=> (define (close-enough? a b)
  (< (abs (- a b)) 0.0001))
;Value: close-enough?

1 ]=> (define (search f neg-point pos-point)
  (let ((mid-point (average neg-point pos-point)))
    (if (close-enough? neg-point pos-point)
      mid-point
      (let ((test-value (f mid-point)))
	(cond 
	  ((> test-value 0) (search f neg-point mid-point))
	  ((< test-value 0) (search f mid-point pos-point))
	  (else mid-point))))))
;Value: search

1 ]=> (define (half-interval-method f a b)
  (let ((f-a (f a))
	(f-b (f b)))
    (cond 
      ((and (> f-a 0) (< f-b 0)) (search f b a))
      ((and (< f-a 0) (> f-b 0)) (search f a b))
      (else (error "values not right" a b)))))
;Value: half-interval-method

1 ]=> (half-interval-method (lambda (x) (- 1 (cube x))) -10 10)
;Value: 1.0000228881835937

1 ]=> (half-interval-method sin 2 4)
;Value: 3.141571044921875

1 ]=> (half-interval-method (lambda (x) (- (cube x) (* 2 x) 3)) -10 10)
;Value: 1.8932723999023437

1 ]=> (define (fixed-point f first-guess)
  (let ((next-val (f first-guess)))
    (if (close-enough? first-guess next-val)
      first-guess
      (fixed-point f next-val))))
;Value: fixed-point

1 ]=> (fixed-point cos 1.0)
;Value: .7391301765296711

1 ]=> (fixed-point (lambda (x) (+ (sin x) (cos x))) 1.0)
;Value: 1.2587758014705528

1 ]=> (define (sqrt2 x)
  (fixed-point (lambda (y) (average y (/ x y))) 1.0))
;Value: sqrt2

1 ]=> (fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0)
;Value: 1.6179775280898876

1 ]=> ;1.36
(fixed-point (lambda (x) (/ (log 1000) (log x))) 2.0)
;Value: 4.555493957531389

1 ]=> ;1.37
(define (cont-frac-iter n d k)
  (define (inner n d k place)
    (cond
      ((= k 1) place)
      (else (inner n d (- k 1) (/ (n k) (+ (d k) place))))))
  (inner n d k 0.0))
;Value: cont-frac-iter

1 ]=> (cont-frac-iter 1.0 1.0 100)
;The object 1. is not applicable.
;To continue, call RESTART with an option number:
; (RESTART 2) => Specify a procedure to use in its place.
; (RESTART 1) => Return to read-eval-print level 1.

2 error> (define (cont-frac n d k)
  (define (cont-frac-sub it)
    (if (= k it)
      (/ (n k) (d k))
      (/ (n k) (+ (d k) (cont-frac-sub (+ it 1))))))
  (cont-frac-sub 0))
;Value: cont-frac

2 error> (cont-frac (lambda (x) 1.0) (lambda (x) 1.0) 100)
;Value: .6180339887498948

2 error> (cont-frac (lambda (x) 1.0) 
	   (lambda (x) 
	     (if (= (remainder (+ 1 x) 3) 0) 
	       (* 2 (/ (+ 1 x) 3))
	       1.0)) 100)
;Value: .6180339887498948

2 error> ;1.39
(define (tan-cf x k)
  (- (cont-frac (lambda (k) (- (expt x k)))
	     (lambda (x) (- (* 2.0 k) 1.0))
	     k)))
;Value: tan-cf

2 error> (tan-cf 180 100)
;Value: 3.3176247160066705e221

2 error> (define (average-damp f)
  (lambda (x) (average x (f x))))
;Value: average-damp

2 error> ((average-damp square) 10.0)
;Value: 55.

2 error> (define (sqrt3 x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
	       1.0))
;Value: sqrt3

2 error> (sqrt3 9)
;Value: 3.00009155413138

2 error> (cont-frac (lambda (x) 1.0) 
	   (lambda (x) 
	     (if (= (remainder (+ 1 x) 3) 0) 
	       (* 2.0 (/ (+ 1 x) 3.0))
	       1.0)) 100)
;Value: .6180339887498948

2 error> 
End of input stream reached.
Moriturus te saluto.
